[ { "title": "Static and Dynamic Frameworks", "url": "/posts/static-vs-dynamic-frameworks/", "categories": "Frameworks, Static, Dynamic, Library", "tags": "integration, static, dynamic", "date": "2022-09-30 21:08:00 +0800", "snippet": "Static and Dynamic FrameworksBefore coming to the differences between static and dynamic frameworks, Let’s discuss about what is a framework anyway?Developers often uses frameworks and libraries interchangeably, but there is a subtle difference. Both frameworks and libraries are code written by someone else (or you) to solve a common problem. The key difference between framework and library is inversion control.While using library we are in charge of when and where to call library on the other hand, In the case of framework, framework is in charge of flow.Now, Coming back to static vs dynamic question.##Static Frameworks / LibrariesIn static, code is copy pasted inside our app’s bundle. The static approach is comparatively simple. You can build a static library, use it via importing (e.g. import Foundation). When we compile app, you have to tell the compiler the location of library and the publicly accessible objects that are available to use. This way when app is built, symbols from lib can be copied to the main executable file. When we run the app, required objects will be already present inside the binary file, so you can run it as it is.Dynamic Frameworks / LibrariesIn dynamic, every code is not copied to the executable application. When you use a dylib file some of the “undefined” symbols will be resolved at runtime. When you make the final version of your app, the system will put references of the dynamic library to your executable instead of copying the contents of dylib file. If you want to run your application you have to make sure that the referenced dynamic library is available to use.Some Important PointsIn Static, Code can’t be changed without recompiling application as code is copied into executable binary.In Dynamic, Code can be changed without recompiling application as it’s resolved at runtime.Since, Dynamic libraries live outside the executable file, the program need to make only one copy of the library’s files at compile time. Whereas using a static library means every file in your program must have it’s own copy of the library’s files at compile time.What it means to you if you are Apple Developer?We can include frameworks like Clevertap using Cocoapod as well as carthage. Rule of thumb is if a framework is dynamic then we do no embed it (include in executable as explained above).Xcode offers us three options:Do Not EmbedEmbed &amp; SignEmbed Without SigningHead over to terminal and go to path of framework in reference.For checking if we should embed framework or not (static or not) use,file ABC.framework/frameworkToLinkIf it gives, current ar archive it means it’s static.If it gives, Mach-O dynamically linked.For checking, if we should sign framework or not, use:codesign -dv frameworkToLink.frameworkIf it gives adhoc, then we need to sign it else it’s already signed.References: Stack Overflow The Difference Between a Framework and a Library Inversion of Control Building static and dynamic Swift libraries using the Swift compiler " }, { "title": "Lazy Property Observers", "url": "/posts/lazy-property-observers/", "categories": "Swift, Lazy Property Observers", "tags": "swift, lazy property observers", "date": "2022-09-30 05:10:00 +0800", "snippet": "From Swift 5.3 onwards, property observers can be attached to lazy properties as well. This means, we can observe when a new value was assigned to a given property, even if its value is lazily loaded when first accessed.Consider a case where you want to read a file and as soon as it’s loaded and validated, you want to send it in a email. Let’s do it without observer first.import UIKitclass FileDownloader { lazy var file : String = { let file = readBigFile() return file }() private func readBigFile() -&gt; String { var data = \"\" for i in 1 ... 1000000000000000 { data += \"\\(i)\" } return data } // Method that will be used by user to load file func loadFile() { _ = file validateFileAndSendEmail() } func validateFileAndSendEmail() { // Validate file sendEmail() } private func sendEmail() { print(file) }}In this we are validating and sending file just after file is loaded.Let’s make it a bit neater by using property observer.class FileDownloader { lazy var file : String = { let file = readBigFile() return file }() { didSet { validateFileAndSendEmail() } } private func readBigFile() -&gt; String { var data = \"\" for i in 1 ... 1000000000000000 { data += \"\\(i)\" } return data } // Method that will be used by user to load file func loadFile() { _ = file } func validateFileAndSendEmail() { // Validate file sendEmail() } private func sendEmail() { print(file) }}Reference: Lazy property observers https://github.com/apple/swift/issues/49631" } ]
