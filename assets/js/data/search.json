[ { "title": "Live Activity", "url": "/posts/live-activity/", "categories": "Swift, Live Activity", "tags": "swift, live activity", "date": "2022-09-30 06:10:00 +0800", "snippet": "In iOS 16, Apple introduced Live Activity. Live activity will display your app’s most recent data on lock screen as well as dynamic island. This will let user consume data just by glancing on screen.This can be used for variety of use cases. From giving updates to customers about location of delivery partner to telling scores of some game.For our case, we will implement a live activity which will tell us who has highest step count in a marathon.Some key things to be considered. Activity can only be started when app is in foreground. i.e. We can’t launch activity if app is in killed state. One activity can be live for only 8 hours, which means it has defined start and defined end. We can update live activity via push notifications as well by app. We can’t make api calls as well as fetch users location in paradigm of live activity.In our example, there is a big race going on among Bheem, Bholu and Chutki. Everyone wants to know who is leading this race. For keeping our audience well informed we will create one app which will let them see current position on their lock screen itself.Open XCode and create a new app. For this example, we are using storyboard and Swift based app.Define Runner Model for our runners:struct Runner { var runnerId: String var steps: Int}In our ViewController, let’s create a runners array.var runners: [Runner] = [.init(runnerId: \"Bheem\", steps: 0), .init(runnerId: \"Chutki\", steps: 1), .init(runnerId: \"Bholu\", steps: 2)]Now, we need to tell OS that our app supports live activity. For this headover to Info.plist and set NSSupportsLiveActivities flag to true.Let’s start with real stuff now. Add a new widget target.What we add on widget is what user will see on his lock screen.Remove all template code and import ActivityKit.import ActivityKitimport WidgetKitimport SwiftUI@mainstruct LiveActivity: Widget { var body: some WidgetConfiguration { .... }}Here, @main denotes the main target or first thing that is to be run for this target.Now, we will create activity’s UI first. Once it’s done we will target Dynamic Island.ActivityConfiguration is of generic type. While creating activity we will need to pass the type of attributes our activity responds to. In general, it is of two types: Content State: Changes with time. It represents Updates Static Data: Do not change with time. E.g. Restaurant name for some order.Let’s create Attributes which conforms to ActivityAttributes protocol.struct LiveActivityAttributes: ActivityAttributes { typealias ContentState = Runner}Now for using Runner we need to do two things: Move this to a new file and check both targets as true. Make Runner conform to Hashable and Codable protocols.struct Runner: Codable, Hashable { var runnerId: String var steps: Int}Post this we should have.import ActivityKitimport WidgetKitimport SwiftUI@mainstruct LiveActivity: Widget { var body: some WidgetConfiguration { ActivityConfiguration&lt;LiveActivityAttributes&gt; { context in Text(\"\") } dynamicIsland: { context in DynamicIsland { DynamicIslandExpandedRegion(.center) { Text(\"\") } } compactLeading: { } compactTrailing: { } minimal: { } } }}Let’s replace Text(\"\") with real view.Since, we can’t make api calls in live activity; we won’t be able to download images as well. Since we have only 3 players we can add their images into our bundle.struct CompetitionInfo: View { var runner: Runner var body: some View { ZStack { HStack { Image(runner.runnerId).resizable().frame(width: 80, height: 80) Spacer() Text(\"Steps: \\(runner.steps)\") .font(.largeTitle) }.padding(16) } }}After this, we will have:@mainstruct LiveActivity: Widget { var body: some WidgetConfiguration { ActivityConfiguration&lt;LiveActivityAttributes&gt; { context in CompetitionInfo(context.state) ......Here context.state will contain runner object.Now, Our main app supports live activity and our live activity’s UI is also ready. Let’s stitch them together.Live Activity Life CycleStarting Live ActivityBefore starting live activity let’s check if live activities are enabled. We can do this by:ActivityAuthorizationInfo().areActivitiesEnabledLet’s start live activityguard ActivityAuthorizationInfo().areActivitiesEnabled else { return}let staticAttributes = LiveActivityAttributes()let dynamicData: LiveActivityAttributes.ContentState = .init(runnerId: \"Bheem\", steps: 1)let activity = try? Activity&lt;LiveActivityAttributes&gt;.request(attributes: staticAttributes, contentState: dynamicData, pushType: .token)Once live activity is started we will see it in lock screen as well as notification tray.Updating Live ActivityEvery activity that we create has a unique id and token using which we can update them. Whenever an event occurs let’s update activity if it exists and create one if it does not.func getActivity(runner: Runner) -&gt; Activity&lt;LiveActivityAttributes&gt;? { let activities = Activity&lt;LiveActivityAttributes&gt;.activities let activity = activities.first { $0.contentState.runnerId = runner.runnerId } return activity}Now whenever we get update. We check if activity exists: If it does, we update. If it does not we start.Let’s write a method for handling this now.func updateOrStartActivity(runner: Runner) { guard ActivityAuthorizationInfo().areActivitiesEnabled else { return } let activity = getActivity(runner: runner) if activity == nil { startActivity(runner: runner) } else { Task { await updateActivity(activity: activity, contentState: runner) } }}func startActivity(runner: Runner) { do { let activity = try Activity&lt;LiveActivityAttributes&gt;.request(attributes: .init(), contentState: runner) } catch { print(error) }}func getActivity(runner: Runner) -&gt; Activity&lt;LiveActivityAttributes&gt;? { let activities = Activity&lt;LiveActivityAttributes&gt;.activities let activity = activities.first { $0.contentState.runnerId == runner.runnerId } return activity}End ActivityWe can also end activity once we are done with it.func endActivity(runner: Runner) { let activity = getActivity(runner: runner) await activity?.end()}So far we have created, updated and ended our activities. This will work as long as our app is not killed.For majority of use cases, this is not enough. Luckily, we can do update and end operations by notifcation as well.Updating Live Activities using push notificationsFor updating our activities with push notification we need to setup push notifications in our app.Now, while starting activity set pushType to .token. let activity = try Activity&lt;LiveActivityAttributes&gt;.request(attributes: .init(), contentState: runner, pushType: .token)Each activity will have a unique token using which we can update it. We can listen to pushTokenUpdates by:Task { for await data in activity.pushTokenUpdates { let token = data.map {String(format: \"%02x\", $0)}.joined() }}Pass this token to backend. Notification targetted to this token will update activity.For setting up notification service refer Update your app’s code and create a push notification serverHandling DeeplinkWhen user clicks on app let’s take user to page that shows selected runners information.For this we can use Link.struct CompetitionInfo: View { var runner: Runner var body: some View { Link(destination: URL) { ZStack { HStack { Image(runner.runnerId).resizable().frame(width: 80, height: 80) Spacer() Text(\"Steps: \\(runner.steps)\") .font(.largeTitle) }.padding(16) } } }}Luminescense Reduced ModeiPhone 14 offers always on display. To save battery it dims the display. Which means your activity will still be visible and you need to handle that as well.For handling this, we need to observe when screen is dimmed and change our UI.First, we add observer.@Environment(\\.isLuminanceReduced) var isLuminanceReducedNow, when luminanceIsReduced, we add a white BG Color.var body: some View { ZStack { if isLuminanceReduced { Color.white } Link(destination: URL) { ZStack { HStack { Image(runner.runnerId).resizable().frame(width: 80, height: 80) Spacer() Text(\"Steps: \\(runner.steps)\") .font(.largeTitle) }.padding(16) } } }}References https://developer.apple.com/documentation/activitykit/displaying-live-data-with-live-activities https://developer.apple.com/documentation/usernotifications https://developer.apple.com/documentation/swiftui/link https://developer.apple.com/documentation/activitykit/update-and-end-your-live-activity-with-remote-push-notifications" }, { "title": ".allSatisfy", "url": "/posts/allSatisfy/", "categories": "Swift, .allSatisfy", "tags": "swift", "date": "2022-09-30 06:00:00 +0800", "snippet": "This is useful for cases where you need to check if a particular condition applies across collection of objects.For example, school will take children to picnic if all children get permission from parentsprotocol PicnicPermission { var hasPermission: Bool}struct Student: PicnicPermission { var name: String var hasPermission: Bool}Lets take one array of studens:let array: [Student] = [.init(name: \"ABC\", hasPermission: true), .init(name: \"DEF\", hasPermission: true)]We can see if all of children meet our condition by iterating over array and ensuring for each element hasPermission is true. We can even filter out students for which this hasPermission is false.for each in array { if each.hasPermission == false { print(\"Picnic is not gonna happen\") }}let childrenWithoutPermission = array.filter{$0.hasPermission == false}if childrenWithoutPermission.isEmpty == false { print(\"Picnic is not gonna happen\")}allSatisfyLet’s solve this problem by using allSatisfy.if array.allSatisfy {$0.hasPermission == true} == false { print(\"Picnic is not gonna happen\")}" }, { "title": "Lazy Property Observers", "url": "/posts/lazy-property-observers/", "categories": "Swift, Lazy Property Observers", "tags": "swift, lazy property observers", "date": "2022-09-30 05:10:00 +0800", "snippet": "From Swift 5.3 onwards, property observers can be attached to lazy properties as well. This means, we can observe when a new value was assigned to a given property, even if its value is lazily loaded when first accessed.Consider a case where you want to read a file and as soon as it’s loaded and validated, you want to send it in a email. Let’s do it without observer first.import UIKitclass FileDownloader { lazy var file : String = { let file = readBigFile() return file }() private func readBigFile() -&gt; String { var data = \"\" for i in 1 ... 1000000000000000 { data += \"\\(i)\" } return data } // Method that will be used by user to load file func loadFile() { _ = file validateFileAndSendEmail() } func validateFileAndSendEmail() { // Validate file sendEmail() } private func sendEmail() { print(file) }}In this we are validating and sending file just after file is loaded.Let’s make it a bit neater by using property observer.class FileDownloader { lazy var file : String = { let file = readBigFile() return file }() { didSet { validateFileAndSendEmail() } } private func readBigFile() -&gt; String { var data = \"\" for i in 1 ... 1000000000000000 { data += \"\\(i)\" } return data } // Method that will be used by user to load file func loadFile() { _ = file } func validateFileAndSendEmail() { // Validate file sendEmail() } private func sendEmail() { print(file) }}Reference: Lazy property observers https://github.com/apple/swift/issues/49631" }, { "title": "Static and Dynamic Frameworks", "url": "/posts/static-vs-dynamic-frameworks/", "categories": "Frameworks, Static, Dynamic, Library", "tags": "integration, static, dynamic", "date": "2022-09-30 02:46:00 +0800", "snippet": "Static and Dynamic FrameworksBefore coming to the differences between static and dynamic frameworks, Let’s discuss about what is a framework anyway?Developers often uses frameworks and libraries interchangeably, but there is a subtle difference. Both frameworks and libraries are code written by someone else (or you) to solve a common problem. The key difference between framework and library is inversion control.While using library we are in charge of when and where to call library on the other hand, In the case of framework, framework is in charge of flow.Now, Coming back to static vs dynamic question.##Static Frameworks / LibrariesIn static, code is copy pasted inside our app’s bundle. The static approach is comparatively simple. You can build a static library, use it via importing (e.g. import Foundation). When we compile app, you have to tell the compiler the location of library and the publicly accessible objects that are available to use. This way when app is built, symbols from lib can be copied to the main executable file. When we run the app, required objects will be already present inside the binary file, so you can run it as it is.Dynamic Frameworks / LibrariesIn dynamic, every code is not copied to the executable application. When you use a dylib file some of the “undefined” symbols will be resolved at runtime. When you make the final version of your app, the system will put references of the dynamic library to your executable instead of copying the contents of dylib file. If you want to run your application you have to make sure that the referenced dynamic library is available to use.Some Important PointsIn Static, Code can’t be changed without recompiling application as code is copied into executable binary.In Dynamic, Code can be changed without recompiling application as it’s resolved at runtime.Since, Dynamic libraries live outside the executable file, the program need to make only one copy of the library’s files at compile time. Whereas using a static library means every file in your program must have it’s own copy of the library’s files at compile time.What it means to you if you are Apple Developer?We can include frameworks like Clevertap using Cocoapod as well as carthage. Rule of thumb is if a framework is dynamic then we do no embed it (include in executable as explained above).Xcode offers us three options:Do Not EmbedEmbed &amp; SignEmbed Without SigningHead over to terminal and go to path of framework in reference.For checking if we should embed framework or not (static or not) use,file ABC.framework/frameworkToLinkIf it gives, current ar archive it means it’s static.If it gives, Mach-O dynamically linked.For checking, if we should sign framework or not, use:codesign -dv frameworkToLink.frameworkIf it gives adhoc, then we need to sign it else it’s already signed.References: Stack Overflow The Difference Between a Framework and a Library Inversion of Control Building static and dynamic Swift libraries using the Swift compiler " } ]
